<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>state-interface</title>
</head>

<body>
    <main id="app">
    </main>
    <script src="./build/main.js"></script>
    <script>
        const elmApp = Elm.Main.init({ node: document.getElementById("app") });

        // copied and edited from https://github.com/elm/virtual-dom/blob/master/src/Elm/Kernel/VirtualDom.js
        // XSS ATTACK VECTOR CHECKS
        //
        // For some reason, tabs can appear in href protocols and it still works.
        // So '\tjava\tSCRIPT:alert("!!!")' and 'javascript:alert("!!!")' are the same
        // in practice.
        //
        // Pulling the regular expressions out to the top level gives a slight speed
        // boost in small benchmarks (4-10%) but hoisting values to reduce allocation
        // can be unpredictable in large programs where JIT may have a harder time with
        // functions are not fully self-contained. The benefit is more that the js and
        // js_html ones are so weird that I prefer to see them near each other.
        const RE_script = /^script$/i;
        function noScript(tag) {
            return RE_script.test(tag) ? 'p' : tag
        }

        const interfaceImplementations = [
            {
                on: event => event?.addRequestTimeNow,
                run: (config, sendToElm) => {
                    sendToElm(Date.now())
                },
            },
            {
                on: event => event?.replaceDomNode,
                run: (config, sendToElm) => {
                    // console.log("replace dom node ", config.path)
                    renderDomNode(config.path, config.domNode, sendToElm)
                }
            },
            {
                on: event => event?.removeDom,
                run: (config, sendToElm) => {
                    console.log("remove dom")
                    document.getElementById("app").replaceChildren() // remove all subs
                }
            }
        ]

        function renderDomNode(path, node, sendToElm) {
            const createdDomNode = createDomNode([], node, sendToElm)
            if (path.length === 0) {
                const parentDomNode = document.getElementById("app")
                parentDomNode.replaceChildren() // remove all subs
                parentDomNode.appendChild(createdDomNode)
            } else {
                let parentDomNode = document.getElementById("app").firstChild
                path.slice(1, path.length).reverse().forEach(subIndex => {
                    parentDomNode = parentDomNode.childNodes[subIndex]
                })
                parentDomNode.replaceChild(
                    createdDomNode, // new
                    parentDomNode.childNodes[path[0]] // old
                )
            }
        }

        function createDomNode(innerPath, node, sendToElm) {
            if (node?.text) {
                return document.createTextNode(node.text)
            } else if (node?.element) {
                const createdDomElement = document.createElement(noScript(node.element.tag))
                for (let [attributeKey, attributeValue] of Object.entries(node.element.attributes)) {
                    createdDomElement.setAttribute(attributeKey, attributeValue)
                }
                for (let [styleKey, styleValue] of Object.entries(node.element.styles)) {
                    createdDomElement.style[styleKey] = styleValue
                }
                node.element.eventListeners.forEach(eventListenerName => {
                    createdDomElement.addEventListener(
                        eventListenerName,
                        (triggeredEvent) => {
                            sendToElm({ innerPath: innerPath, name: eventListenerName, event: triggeredEvent })
                        }
                    )
                })
                for (let subIndex = 0; subIndex <= node.element.subs.length - 1; subIndex++) {
                    const sub = node.element.subs[subIndex]
                    createdDomElement.appendChild(
                        createDomNode([subIndex].concat(innerPath), sub, sendToElm)
                    )
                }
                return createdDomElement
            }
        }

        elmApp.ports.toJs.subscribe(function (fromElm) {
            // console.log("elm → js: ", fromElm)
            function sendToElm(eventData) {
                const toElm = { diff: fromElm, eventData: eventData }
                elmApp.ports.fromJs.send(toElm)
                // console.log("js → elm: ", toElm)
            }

            interfaceImplementations.forEach(interfaceImplementation => {
                if (interfaceImplementation.on(fromElm)) {
                    const specific = interfaceImplementation.on(fromElm)
                    interfaceImplementation.run(specific, sendToElm)
                }
            })
        });
    </script>
</body>

</html>